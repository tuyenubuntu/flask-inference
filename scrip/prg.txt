#File app.py

from flask import Flask, render_template, Response, url_for, send_file
from flask_socketio import SocketIO, emit
import stream_webcam 
import stream
import argparse
parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument("--host", default='0.0.0.0', type=str, help="interface for the webserver to use (default is all interfaces, 0.0.0.0)")
parser.add_argument("--port", default=5000, type=int, help="port used for webserver (default is 8050)")
parser.add_argument("--input", default='webrtc://@:8554/input', type=str, help="input camera stream or video file")
parser.add_argument("--input-webcam", type=int, default=0 , help="Input video source (default is webcam).")
parser.add_argument("--input-usb", type=str, default='/dev/video0' , help="Input video source (default is webcam).")
parser.add_argument("--debug", action='store_true')
parser.add_argument("--detection", default='', type=str, help="load object detection model (see detectNet arguments)")
parser.add_argument("--labels", default='', type=str, help="path to labels.txt for loading a custom model")
parser.add_argument("--colors", default='', type=str, help="path to colors.txt for loading a custom model")
parser.add_argument("--input-layer", default='', type=str, help="name of input layer for loading a custom model")
parser.add_argument("--output-layer", default='', type=str, help="name of output layer(s) for loading a custom model (comma-separated if multiple)")
#boolean
parser.add_argument("--stream-webcam", action='store_true')
parser.add_argument("--stream", action='store_true')
parser.add_argument("--stream-usb", action='store_true')
parser.add_argument("--jetson", action='store_true')
parser.add_argument("--opencv", action='store_true')

args = parser.parse_known_args()[0]

streams = stream_webcam.Stream(args)
if args.stream:
    streams = stream.Stream(args)

streams.start()
app = Flask(__name__)
socketio = SocketIO(app)

# Khởi tạo luồng stream
# stream = Streams()

@app.route('/')
def index():
    return render_template('index.html')


@app.route('/stream')
def stream_video():
    return render_template('stream.html')


@app.route('/video')
def video():
    """Return the MJPEG stream or a placeholder."""
    if streams.is_streaming:
        return Response(streams.generate(),
                        mimetype='multipart/x-mixed-replace; boundary=frame')
    # Return a placeholder image if the stream is not running
    return send_file('static/nocap.png', mimetype='image/png')  # Update with your placeholder path

    
    
@app.route('/info')
def info():
    return render_template('info.html')    


@app.route('/start_stream')
def start_stream():
    """Start the video stream."""
    streams.run_stream()
    return "Stream started."

@app.route('/stop_stream')
def stop_stream():
    """Stop the video stream."""
    streams.stop_stream()
    return "Stream stopped."


@socketio.on('navigate')
def handle_navigation(data):
    target = data.get('target')
    if target == 'home':
        emit('redirect', {'target': url_for('index')})
    elif target == 'info':
        emit('redirect', {'target': url_for('info')})
    elif target == 'stream_video':
        emit('redirect', {'target': url_for('stream_video')})


if __name__ == '__main__':
    socketio.run(app, host=args.host, port=args.port, debug=args.debug)



#File stream_webcam.py

import cv2
import threading

class Stream(threading.Thread):
    def __init__(self, args):
        super().__init__()
        self.args = args
        self.camera = None  # Camera will be initialized when the stream starts
        self.is_streaming = False  # Stream is initially stopped
        self.lock = threading.Lock()  # Thread-safe operations for starting/stopping
        #self.input_source = 0

    def run_stream(self):
        """Start the stream."""
        with self.lock:
            if not self.is_streaming:
                self.camera = cv2.VideoCapture(self.args.input_usb)  # Adjust input source if necessary
                self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)  # Set width
                self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)  # Set height
                self.camera.set(cv2.CAP_PROP_FPS, 60)  # Set FPS
                self.is_streaming = True

    def stop_stream(self):
        """Stop the stream."""
        with self.lock:
            self.is_streaming = False
            if self.camera:
                self.camera.release()
                self.camera = None

    def generate(self):
        """Yield frames for MJPEG streaming."""
        while self.is_streaming:
            ret, frame = self.camera.read()
            if not ret:
                break  # If frame is not read, stop the loop
            ret, jpeg = cv2.imencode('.jpg', frame)
            if ret:
                frame = jpeg.tobytes()
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n\r\n')
        # Ensure the camera is released if streaming stops
        self.stop_stream()


#File stream.py

import cv2
import sys
import threading
import traceback
import argparse
# from model import Model
#from jetson_utils import videoSource, videoOutput


class Stream(threading.Thread):
    """
    Thread for streaming video and applying DNN inference
    """
    def __init__(self, args):
        """
        Create a stream from input/output video sources, along with DNN models.
        """
        super().__init__()
        
        self.args = args
        self.input = videoSource(args.input, argv=sys.argv)
        self.output = videoOutput(args.output, argv=sys.argv)
        self.frames = None
        self.net = detectNet(model=model, labels=labels, colors=colors,
        input_blob=input_layer, 
        output_cvg=output_layer['scores'], 
        output_bbox=output_layer['bbox'])
        # self.models = {}



#File index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Stream</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <h1>Welcome to the Camera Stream App</h1>
    <!-- <img src="{{ url_for('video') }}" alt="Camera Stream" id="video-stream"> -->
    <a href="{{ url_for('stream_video') }}">
        <button>Go to Stream</button>
    </a>
</body>
</html>


#File stream.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.socket.io/4.1.3/socket.io.min.js"></script>
</head>
<body>
    <h1>Camera Stream</h1>
    <img src="{{ url_for('video') }}" alt="Camera Stream" id="video-stream">

    <!-- Buttons to control the stream -->
     <div class="button-row">  
        <button id="start-stream">Start Stream</button>
        <button id="stop-stream">Stop Stream</button>
        <button id="back-to-home">Back to Home</button>
     </div>

    <script>
        document.getElementById('start-stream').addEventListener('click', function () {
            fetch('/start_stream')
                .then(response => response.text())
                .then(data => {
                    alert(data);  // Show server response
                    // Switch to the video stream
                    const videoStream = document.getElementById('video-stream');
                    videoStream.src = "/video?" + new Date().getTime(); // Add a timestamp to prevent caching
                })
                .catch(error => console.error('Error starting stream:', error));
        });

        document.getElementById('stop-stream').addEventListener('click', function () {
            fetch('/stop_stream')
                .then(response => response.text())
                .then(data => {
                    alert(data);  // Show server response
                    // Switch back to the placeholder image
                    const videoStream = document.getElementById('video-stream');
                    videoStream.src = "/static/nocap.png"; // Path to your placeholder image
                })
                .catch(error => console.error('Error stopping stream:', error));
        });



        document.getElementById('back-to-home').addEventListener('click', function () {
            window.location.href = '/';
        });
    </script>
</body>
</html>



#File info.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Stream Info</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.socket.io/4.1.3/socket.io.min.js"></script>  <!-- Kết nối với Socket.IO -->
</head>
<body>
    <h1>Camera Information</h1>
    <p>Here you can get some camera details...</p>
<!--
    <a href="{{url_for('stream_video')}}">
        <button>Back to Stream</button>
    </a>
    <a href="{{url_for('index')}}">
        <button>Back to Home</button>
    </a>

-->


    <p id="serverResponse"></p>

    <button id="back-to-home">Back to Home</button>
    <button id="stream-video">Stream Video</button>


    <script type="text/javascript">
        // Kết nối với server thông qua Socket.IO
        var socket = io.connect('http://' + document.domain + ':' + location.port);

        // Lắng nghe sự kiện 'response' từ server
        socket.on('response', function(data) {
            document.getElementById('serverResponse').innerText = data.data;
        });


                // Nút Back to Home
        document.getElementById('back-to-home').addEventListener('click', function() {
            socket.emit('navigate', { target: 'home' }); // Gửi sự kiện điều hướng
        });
                // Nút Back to Home
        document.getElementById('stream-video').addEventListener('click', function() {
            socket.emit('navigate', { target: 'stream_video' }); // Gửi sự kiện điều hướng
        });

        // Xử lý điều hướng từ server
        socket.on('redirect', function(data) {
            if (data.target) {
                window.location.href = data.target; // Điều hướng tới trang khác
            }
        });


    </script>
</body>
</html>


#File Dockerfile

# Base image Ubuntu với Python 3.9
FROM python:3.9-slim

# Cài đặt các thư viện hệ thống cần thiết
RUN apt-get update && apt-get install -y \
    build-essential \
    libopencv-dev \
    python3-dev \
    git \
    && apt-get clean

# Tạo thư mục làm việc
WORKDIR /jetson-inference

# Copy file requirements.txt
COPY requirements.txt /jetson-inference/

# Cài đặt các thư viện Python
# RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --no-cache-dir --no-warn-script-location -r requirements.txt


# Clone và cài đặt jetson-inference (nếu cần)
# RUN git clone https://github.com/dusty-nv/jetson-inference.git && \
#     cd jetson-inference && mkdir build && cd build && \
#     cmake ../ && make && make install

# Copy mã nguồn vào container
COPY . /jetson-inference/

# Expose cổng Flask
EXPOSE 5000

# Lệnh chạy ứng dụng Flask
CMD ["python", "app.py"]




#structor

stream/
├── flaskapp/                      # Thư mục chứa mã nguồn chính của ứng dụng
│   ├── app.py           # Khởi tạo ứng dụng Flask, đăng ký các module/extension
│   ├── stream.py             # Định nghĩa các route (URL endpoint)
│   ├── models.py             # Định nghĩa các model cơ sở dữ liệu
│   ├── forms.py              # Các biểu mẫu (form) nếu sử dụng Flask-WTF
│   ├── static/               # Chứa các tệp tĩnh (CSS, JavaScript, hình ảnh, fonts)
│   │   ├── css/
│   │   │   └── style.css
│   │   ├── js/
│   │   │   └── app.js
│   │   └── images/
│   │       └── logo.png
│   ├── templates/            # Chứa các tệp HTML template
│   │   ├── stream.html         # Template cơ bản để các trang khác mở rộng
│   │   ├── index.html        # Trang chủ
│   │   └── info.html        # Trang lỗi 404, 500
│   └── utils.py              # Các hàm tiện ích hoặc logic tái sử dụng
├── docker/                      # Thư mục chứa mã nguồn chính của ứng dụng
│   ├── Dockerfile           # Khởi tạo docker
│   ├── requirement.txt            # requirement
│   ├── 


├── config.py                 # Tệp cấu hình ứng dụng
├── instance/                 # Thư mục chứa cấu hình môi trường cục bộ (nếu cần)
│   └── config.py             # Tệp cấu hình riêng tư (có thể bị ignore)
├── migrations/               # Thư mục chứa các tệp di trú cơ sở dữ liệu (tự tạo bởi Flask-Migrate)
├── tests/                    # Thư mục chứa các tệp kiểm thử
│   ├── __init__.py
│   ├── test_routes.py        # Kiểm thử các route
│   └── test_models.py        # Kiểm thử các model
├── run.py                    # Điểm khởi chạy ứng dụng Flask
├── requirements.txt          # Danh sách các thư viện cần thiết
├── .env                      # Tệp chứa các biến môi trường (bí mật, ví dụ SECRET_KEY)
└── venv/                     # Virtual environment (thư mục môi trường ảo - tùy chọn)

